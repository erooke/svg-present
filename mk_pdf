#! /usr/bin/env python
import os
from argparse import ArgumentParser, Namespace
from multiprocessing import Pool
from pathlib import Path
from subprocess import DEVNULL, run
from tempfile import TemporaryDirectory
from typing import Iterator
from xml.etree import ElementTree


def main() -> None:
    """
    Renders a pdf slideshow from a single svg.
    This process happens in three steps:
        0. Parse user input
        1. Split the svg into one svg file per slide
        2. Use inkscape to render each of these svgs to pdfs
        3. Combine each pdf into one master pdf
    """
    presentation = Tree()

    args = parse_args()

    for file in find_svgs(args.files):
        sub_presentation = load_presentation(file)
        presentation.children.append(sub_presentation)

    merge_cmd = [
        "gs",
        "-dBATCH",
        "-dNOPAUSE",
        "-q",
        "-sDEVICE=pdfwrite",
        "-sOutputFile=" + args.output,
    ]

    count = 0

    pool = Pool(args.threads)

    # Split the slides, start the rendering pool
    print("\r  Splitting Slides", end="")
    with TemporaryDirectory() as dir_name:
        directory = Path(dir_name)
        while next(presentation):
            svg = directory / (str(count) + ".svg")
            pdf = directory / (str(count) + ".pdf")
            merge_cmd.append(pdf)
            presentation.children[presentation.index].tree.write(svg)
            pool.apply_async(run, (["inkscape", "-o", pdf, svg],), dict(stderr=DEVNULL))
            count += 1
        print("\r✓ Splitting Slides")

        print("  Rendering Slides", end="")
        pool.close()
        pool.join()
        print("\r✓ Rendering Slides")

        # Merge each of the pdfs into one pdf
        print("  Merging slides", end="")
        run(merge_cmd)
        print("\r✓ Merging slides")


def parse_args() -> Namespace:

    parser = ArgumentParser(
        description="A python script to create slides using inkscape"
    )

    parser.add_argument("files", metavar="file", nargs="+", help="Inkscape file to use")

    parser.add_argument(
        "-o",
        "--output",
        metavar="file",
        help="Output for the slideshow",
        nargs="?",
        default="talk.pdf",
    )

    parser.add_argument(
        "-j",
        "--threads",
        metavar="num",
        help="How many inkscape processess to spawn",
        nargs="?",
        type=int,
        default=None,
    )

    return parser.parse_args()


def inkscape(name: str) -> str:
    """Add the inkscape namespace to a name"""
    return "{http://www.inkscape.org/namespaces/inkscape}" + name


class Tree:
    def __init__(self, element=None) -> None:
        self.children = []
        self.element = element
        self.tree: ElementTree.ElementTree | None = None
        self.index: int | None = None


def next(tree: Tree) -> bool:
    """Move to the next slide"""
    if tree.index is None:
        # Initial setup
        tree.index = 0

        if tree.element is not None:
            tree.element.set("style", "display:inline")

        if tree.children:
            next(tree.children[0])

        return True

    try:
        if not next(tree.children[tree.index]):
            tree.index += 1
            next(tree.children[tree.index])

    except IndexError:
        # If at any point we run out of children there is no next element
        if tree.element:
            tree.element.set("style", "display:none")
        return False

    return True


def layer(element: ElementTree.Element) -> Tree | None:
    if element.get(inkscape("groupmode")) != "layer":
        return None

    label = element.get(inkscape("label"))

    if label is None:
        return None

    if label[0] == "(" and label[-1] == ")":
        return None

    element.set("style", "display:none")
    tree = Tree(element)

    for child in element:
        if subtree := layer(child):
            tree.children.append(subtree)

    return tree


def load_presentation(file: Path) -> Tree:
    """Load a presentation from an svg file on disk"""
    tree = ElementTree.parse(file)
    root = tree.getroot()
    slides = Tree()
    slides.tree = tree
    for child in root:
        if sub_slides := layer(child):
            slides.children.append(sub_slides)

    return slides


def find_svgs(names: list[str]) -> Iterator[Path]:
    for path in map(Path, names):
        if path.is_file():
            yield path
            continue

        for directory, dirs, files in os.walk(path):
            # This ensures the directories are traveresed in a sensible order
            dirs.sort()
            files.sort()
            for file in files:
                if not file.endswith(".svg"):
                    continue
                yield Path(directory) / file


if __name__ == "__main__":
    main()
